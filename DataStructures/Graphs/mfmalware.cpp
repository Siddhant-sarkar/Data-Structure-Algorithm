#include"bits/stdc++.h"
using namespace std;
class DSU {
private:
	vector<int> par,rank;
public:
	DSU(int n){
		par.resize(n);rank.resize(n);
		for(int i=0;i<n;i++){
			par[i] = i;
			rank[i] = 1;
		}
	}
	bool unite(int x,int y){
		int lx = find(x);
		int ly = find(y);
		if(lx != ly){
			if (rank[lx]<rank[ly]){
				swap(lx,ly);
			}
			par[ly] = lx;
			rank[lx] +=rank[ly];
			return true;	
		}
		return false;
	}
	int find(int x){
		if(par[x]==x ) return x;
		return par[x] = find(par[x]);
	}
	int size(int x){
		return rank[find(x)] ;
	}
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
 		int N = graph.size();
 		DSU ds =  DSU(N);
 		set<int> ini;
 		for(int i:initial){ ini.insert(i); }
 		for(int u=0;u<N;u++){
 			if(ini.count(u) == 0){
 				for(int v=0;v<N;v++){
 					if(ini.count(v) == 0){
 						ds.unite(u,v);
 					}
 				}
 			}
 		}
 		vector<int> count(N,0);
 		map<int, set<int>>  nodeToComp;
 		for(int u : initial){
 			set<int> temp;
 			for(int v=0;v<N;v++) {
 				if(ini.count(v) == 0 && graph[u][v]){
 					temp.insert(ds.find(v));
	 			}
			}
			nodeToComp.insert({u,temp});
			for(int i : temp){
				count[i]++;
			}
 		}
 		int ans = -1, ansSize=-1;
 		for( auto [a,b] : nodeToComp){
 			set<int> temp =b;
 			int score=0;	
 			for(int k : b){
 				if(count[ k] ==1){
 					score+=ds.size(k);
 				}
 			}
 			if((score>ansSize || score == ansSize) && a<ans){
 				ans=a;
 				ansSize=score;
 			}
 		}
 		return ans;
    }
};

int main(){
	cout<<"Congrats, Huston"<<endl;
}